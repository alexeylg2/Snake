<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Змейка Nokia 6600</title>
  <!-- Подключаем p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
  <style>
    body { 
      margin: 0; 
      padding: 0; 
      background: #000; 
      color: #fff; 
      font-family: 'Helvetica', sans-serif;
      position: relative;
    }
    /* Контейнер для игрового поля */
    #game-container {
      display: flex;
      justify-content: center;
      margin-top: 20px;
    }
    /* Меню выбора режима под игровым полем */
    #menu {
      text-align: center;
      margin-top: 20px;
    }
    .menu-button {
      font-size: 18px;
      padding: 10px 20px;
      margin: 5px;
      background-color: #4CAF50;
      border: none;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .menu-button:hover {
      background-color: #45a049;
    }
    /* Красивый счетчик бонусов */
    .score-container {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      padding: 5px 10px;
      border-radius: 8px;
      font-size: 20px;
    }
    /* Оверлей паузного меню */
    #pause-menu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      z-index: 10;
    }
  </style>
</head>
<body>
  <!-- Контейнер для канвы игры -->
  <div id="game-container"></div>
  <!-- Меню выбора режима (начальный экран) -->
  <div id="menu"></div>

  <script>
    // Размер ячейки и размеры игрового поля
    const gridSize = 20;
    const cols = 20;
    const rows = 20;

    let snake = [];
    let direction = { dx: 1, dy: 0 };
    let bonus = {};
    let score = 0;
    
    // Режим управления: "user" или "ai"
    let controlMode = "";
    let gameStarted = false;
    let paused = false;
    let canvas;
    
    // Элементы меню и счетчика
    let aiButton, userButton;
    let scoreDiv;
    let pauseMenuDiv;

    function setup() {
      canvas = createCanvas(cols * gridSize, rows * gridSize);
      canvas.parent('game-container');
      frameRate(10);
      
      // Создаем красивый счетчик бонусов
      scoreDiv = createDiv("Score: 0");
      scoreDiv.class("score-container");
      scoreDiv.parent(document.body);
      
      // Создаем кнопки выбора режима на стартовом экране
      showStartMenu();
      
      resetGame();
    }
    
    function showStartMenu() {
      let menuDiv = select('#menu');
      menuDiv.html(""); // очищаем меню
      
      aiButton = createButton('AI Control');
      aiButton.class("menu-button");
      aiButton.parent(menuDiv);
      aiButton.mousePressed(() => {
        controlMode = "ai";
        gameStarted = true;
        menuDiv.html("");
        resetGame();
      });
      
      userButton = createButton('User Control');
      userButton.class("menu-button");
      userButton.parent(menuDiv);
      userButton.mousePressed(() => {
        controlMode = "user";
        gameStarted = true;
        menuDiv.html("");
        resetGame();
      });
    }
    
    // Сброс игры (начало новой партии)
    function resetGame() {
      snake = [];
      snake.push({ x: floor(cols / 2), y: floor(rows / 2) });
      direction = { dx: 1, dy: 0 };
      score = 0;
      paused = false;
      spawnBonus();
      updateScore();
    }
    
    // Создаем бонус в случайной незанятой ячейке
    function spawnBonus() {
      let valid = false;
      let x, y;
      while (!valid) {
        x = floor(random(cols));
        y = floor(random(rows));
        if (isCellFree(x, y)) {
          valid = true;
        }
      }
      bonus = { x, y };
    }
    
    // Проверяем, что ячейка (x, y) не занята змейкой
    function isCellFree(x, y) {
      for (let part of snake) {
        if (part.x === x && part.y === y) return false;
      }
      return true;
    }
    
    // Проверка столкновения змейки с собой
    function collision(newHead) {
      let willGrow = (newHead.x === bonus.x && newHead.y === bonus.y);
      let bodyToCheck = snake.slice();
      if (!willGrow) {
        bodyToCheck.shift(); // хвост освободится
      }
      for (let segment of bodyToCheck) {
        if (segment.x === newHead.x && segment.y === newHead.y) return true;
      }
      return false;
    }
    
    // Обработка нажатий клавиш
    function keyPressed() {
      // При нажатии Esc - переключаем режим паузы/возобновления
      if (keyCode === ESCAPE) {
        if (!paused) {
          pauseGame();
        } else {
          resumeGame();
        }
        return;
      }
      
      if (paused) return;
      
      if (controlMode === "user") {
        if (keyCode === UP_ARROW && direction.dy !== 1) {
          direction = { dx: 0, dy: -1 };
        } else if (keyCode === DOWN_ARROW && direction.dy !== -1) {
          direction = { dx: 0, dy: 1 };
        } else if (keyCode === LEFT_ARROW && direction.dx !== 1) {
          direction = { dx: -1, dy: 0 };
        } else if (keyCode === RIGHT_ARROW && direction.dx !== -1) {
          direction = { dx: 1, dy: 0 };
        }
      }
    }
    
    // Функция для создания паузного меню
    function pauseGame() {
      paused = true;
      createPauseMenu();
    }
    
    function resumeGame() {
      paused = false;
      removePauseMenu();
    }
    
    function createPauseMenu() {
      pauseMenuDiv = createDiv('');
      pauseMenuDiv.id('pause-menu');
      pauseMenuDiv.parent(document.body);
      
      let resumeBtn = createButton('Resume');
      resumeBtn.class("menu-button");
      resumeBtn.parent(pauseMenuDiv);
      resumeBtn.mousePressed(() => {
        resumeGame();
      });
      
      let exitBtn = createButton('Exit to Main Menu');
      exitBtn.class("menu-button");
      exitBtn.parent(pauseMenuDiv);
      exitBtn.mousePressed(() => {
        paused = false;
        gameStarted = false;
        removePauseMenu();
        resetGame();
        showStartMenu();
      });
    }
    
    function removePauseMenu() {
      if (pauseMenuDiv) {
        pauseMenuDiv.remove();
        pauseMenuDiv = null;
      }
    }
    
    // Функция ИИ для выбора направления (на основе минимальной "манхэттенской" дистанции)
    function chooseDirection() {
      let head = snake[snake.length - 1];
      let moves = [
        { dx: 1, dy: 0 },
        { dx: -1, dy: 0 },
        { dx: 0, dy: 1 },
        { dx: 0, dy: -1 }
      ];
      moves.sort((a, b) => {
        let newAX = (head.x + a.dx + cols) % cols;
        let newAY = (head.y + a.dy + rows) % rows;
        let newBX = (head.x + b.dx + cols) % cols;
        let newBY = (head.y + b.dy + rows) % rows;
        let dA = abs(newAX - bonus.x) + abs(newAY - bonus.y);
        let dB = abs(newBX - bonus.x) + abs(newBY - bonus.y);
        return dA - dB;
      });
      
      for (let move of moves) {
        let newX = (head.x + move.dx + cols) % cols;
        let newY = (head.y + move.dy + rows) % rows;
        let candidate = { x: newX, y: newY };
        if (!collision(candidate)) return move;
      }
      return direction;
    }
    
    // Обновление счетчика бонусов
    function updateScore() {
      scoreDiv.html("Score: " + score);
    }
    
    // Рисуем сетку игрового поля
    function drawGrid() {
      stroke(40);
      strokeWeight(1);
      for (let i = 0; i <= cols; i++) {
        line(i * gridSize, 0, i * gridSize, rows * gridSize);
      }
      for (let j = 0; j <= rows; j++) {
        line(0, j * gridSize, cols * gridSize, j * gridSize);
      }
    }
    
    function draw() {
      // Если игра не запущена (на стартовом экране)
      if (!gameStarted) {
        background(0);
        // Можно вывести текст, но меню уже создано ниже
        return;
      }
      
      background(0);
      drawGrid();
      
      if (paused) {
        // Логика игры при паузе не выполняется,
        // так как pauseMenuDiv уже создан и отображается
        return;
      }
      
      // Если выбран режим ИИ, обновляем направление автоматически
      if (controlMode === "ai") {
        direction = chooseDirection();
      }
      
      let head = snake[snake.length - 1];
      let newX = (head.x + direction.dx + cols) % cols;
      let newY = (head.y + direction.dy + rows) % rows;
      let newHead = { x: newX, y: newY };
      
      if (collision(newHead)) {
        resetGame();
        return;
      }
      
      snake.push(newHead);
      
      if (newHead.x === bonus.x && newHead.y === bonus.y) {
        score++;
        updateScore();
        spawnBonus();
      } else {
        snake.shift();
      }
      
      // Рисуем бонус
      fill(255, 0, 0);
      rect(bonus.x * gridSize, bonus.y * gridSize, gridSize, gridSize);
      
      // Рисуем змейку
      fill(0, 255, 0);
      for (let part of snake) {
        rect(part.x * gridSize, part.y * gridSize, gridSize, gridSize);
      }
    }
  </script>
</body>
</html>
