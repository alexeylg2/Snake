<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ЗМІЙКОКРАТ</title>
  <!-- Подключаем p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
  <!-- Подключаем шрифт "Press Start 2P" -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <!-- Подключаем внешний CSS файл -->
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="wrapper">
    <!-- Контейнер для канвы игры -->
    <div id="game-container"></div>
    <!-- Меню: кнопка "Старт" и таблица рекордов -->
    <div id="menu"></div>
  </div>

  <script>
    // Параметры игрового поля
    const gridSize = 20;
    const cols = 20;
    const rows = 20;
    const borderThickness = 20;
    const canvasWidth = cols * gridSize + 2 * borderThickness;
    const canvasHeight = rows * gridSize + 2 * borderThickness;

    let snake = [];
    let direction = { dx: 1, dy: 0 };
    let bonus = {};
    let score = 0;
    
    let controlMode = "";
    let gameStarted = false;
    let paused = false;
    let gameOver = false;
    let canvas;

    // Интерфейс
    let userButton;
    let scoreDiv;
    let pauseMenuDiv;

    // Рекорды
    let records = [];

    // Авто-демо
    let autoStartTimeout = null;

    // Окно ввода рекорда
    let inputDisplayed = false;
    let scoreSubmitted = false;

    // =============== Работа с рекордами ===============
    function loadRecords() {
      try {
        let stored = localStorage.getItem("snakeRecords");
        if (stored) {
          records = JSON.parse(stored);
        } else {
          records = [];
        }
      } catch(e) {
        console.error("Ошибка доступа к localStorage:", e);
        records = [];
      }
    }

    function saveRecords() {
      try {
        localStorage.setItem("snakeRecords", JSON.stringify(records));
      } catch(e) {
        console.error("Ошибка сохранения в localStorage:", e);
      }
    }

    function updateRecordsTable() {
      let menuDiv = select('#menu');
      let recordDiv = select("#record-table");
      if (!recordDiv) {
        recordDiv = createDiv("");
        recordDiv.id("record-table");
        recordDiv.parent(menuDiv);
      }
      let html = "<h3>Топ гравців</h3><ol>";
      records.forEach(r => {
        html += `<li>${r.name}: <span class="score-number">${r.score}</span></li>`;
      });
      html += "</ol>";
      recordDiv.html(html);
    }

    function qualifies(score) {
      if (records.length < 15) return true;
      return score > records[records.length - 1].score;
    }

    function addRecord(name, score) {
      records.push({ name, score });
      records.sort((a, b) => b.score - a.score);
      if (records.length > 15) records.pop();
      saveRecords();
      updateRecordsTable();
    }

    function showNameInput() {
      let inputDiv = createDiv("");
      inputDiv.id("record-input");
      inputDiv.parent(document.body);
      inputDisplayed = true;
      
      let title = createElement("h3", "Новий рекорд!");
      title.style("color", "#EC612A");
      title.parent(inputDiv);
      
      let info = createP("Введіть своє ім'я (до 12 знаків):");
      info.parent(inputDiv);
      
      let nameInput = createInput("");
      nameInput.attribute("maxlength", "12");
      nameInput.class("name-input");
      nameInput.parent(inputDiv);
      nameInput.elt.focus();

      let submitBtn = createButton("OK");
      submitBtn.class("name-submit");
      submitBtn.parent(inputDiv);
      submitBtn.mousePressed(submitRecord);

      nameInput.elt.addEventListener('keydown', function(evt) {
        evt.stopPropagation();
        if (evt.key === 'Enter') {
          evt.preventDefault();
          submitRecord();
        }
      });

      function escHandler(e) {
        if (e.key === 'Escape') {
          e.stopPropagation();
          removeEscHandler();
          inputDiv.remove();
          scoreSubmitted = true;
        }
      }

      function removeEscHandler() {
        nameInput.elt.removeEventListener('keydown', escHandler);
        document.removeEventListener('keydown', escHandler);
      }

      inputDiv.elt.addEventListener('keydown', escHandler);
      document.addEventListener('keydown', escHandler);

      function submitRecord() {
        let name = nameInput.value().trim();
        if (name === "") name = "ANON";
        addRecord(name, score);
        scoreSubmitted = true;
        removeEscHandler();
        inputDiv.remove();
      }
    }

    // =============== p5: setup, draw ===============
    function setup() {
      pixelDensity(1);
      canvas = createCanvas(canvasWidth, canvasHeight);
      noSmooth();
      canvas.parent('game-container');
      frameRate(10);

      scoreDiv = createDiv("Рахунок: 0");
      scoreDiv.class("score-container");
      scoreDiv.parent(document.body);

      loadRecords();
      showStartMenu();
      resetGame();

      document.addEventListener('keydown', (e) => {
        if (!gameStarted && e.key === 'Enter') {
          if (userButton) {
            userButton.elt.click();
          }
        }
      });
    }

    function draw() {
      if (!gameStarted) {
        if (gameOver) {
          if (controlMode === "user" && qualifies(score) && !scoreSubmitted && !inputDisplayed) {
            showNameInput();
            return;
          }
          background("#1c1c1c");
          noStroke();
          fill(0, 150);
          rect(0, 0, width, height);

          fill("#FF4136");
          textAlign(CENTER, CENTER);
          textSize(60);
          textStyle(BOLD);
          text("GAME OVER", width / 2, height / 2 - 60);

          textSize(24);
          fill(200);
          text("Спробуємо ще?", width / 2, height / 2 + 40);
          return;
        } else {
          background("#1c1c1c");
          let s = 10;
          let artW = 8 * s;
          let artH = 8 * s;
          drawSnakePixelArt(width / 2 - artW / 2, height / 2 - artH - 40, s);
          
          push();
            textSize(48);
            textAlign(CENTER, CENTER);
            fill(0, 0, 0, 128);
            text("ЗМІЙКОКРАТ", width / 2 + 2, height / 2 + 12);
          pop();
          fill("#86BB39");
          textSize(48);
          textAlign(CENTER, CENTER);
          text("ЗМІЙКОКРАТ", width / 2, height / 2 + 10);
          
          let alphaMenu = map(sin(frameCount * 0.2), -1, 1, 100, 255);
          fill(134, 187, 57, alphaMenu);
          textSize(24);
          text("let's begin", width / 2, height / 2 + 50);
          return;
        }
      }

      background("#f0f0f0");
      fill("#343434");
      noStroke();
      rect(borderThickness, borderThickness, cols * gridSize, rows * gridSize);
      drawGrid();

      if (paused) return;

      if (controlMode === "ai") {
        direction = chooseDirection();
      }

      let head = snake[snake.length - 1];
      let newX = (head.x + direction.dx + cols) % cols;
      let newY = (head.y + direction.dy + rows) % rows;
      let newHead = { x: newX, y: newY };

      if (collision(newHead)) {
        gameOver = true;
        gameStarted = false;
      } else {
        snake.push(newHead);
        if (newHead.x === bonus.x && newHead.y === bonus.y) {
          if (controlMode === "user") {
            score++;
            updateScore();
          }
          spawnBonus();
        } else {
          snake.shift();
        }
      }

      fill("#EC612A");
      rect(borderThickness + bonus.x * gridSize, borderThickness + bonus.y * gridSize, gridSize, gridSize);
      fill("#86BB39");
      for (let part of snake) {
        rect(borderThickness + part.x * gridSize, borderThickness + part.y * gridSize, gridSize, gridSize);
      }
    }

    // =============== Логика управления ===============
    function showStartMenu() {
      let menuDiv = select('#menu');
      menuDiv.html("");
      menuDiv.show();
      scoreDiv.hide();

      if (autoStartTimeout) clearTimeout(autoStartTimeout);

      userButton = createMenuButton('Старт', () => {
        if (autoStartTimeout) clearTimeout(autoStartTimeout);
        controlMode = "user";
        gameStarted = true;
        gameOver = false;
        scoreSubmitted = false;
        inputDisplayed = false;
        menuDiv.hide();
        resetGame();
      });

      updateRecordsTable();

      autoStartTimeout = setTimeout(() => {
        if (!gameStarted) {
          controlMode = "ai";
          gameStarted = true;
          scoreSubmitted = false;
          inputDisplayed = false;
          resetGame();
        }
      }, 5000);
    }

    function createMenuButton(label, callback) {
      let button = createButton(label);
      button.class("menu-button");
      button.mousePressed(callback);
      return button;
    }

    function resetGame() {
      snake = [];
      snake.push({ x: floor(cols / 2), y: floor(rows / 2) });
      direction = { dx: 1, dy: 0 };
      score = 0;
      paused = false;
      gameOver = false;
      spawnBonus();
      inputDisplayed = false;

      if (gameStarted && controlMode === "user") {
        scoreDiv.show();
        updateScore();
      } else {
        scoreDiv.hide();
      }
    }

    function keyPressed() {
      if (gameOver) {
        if (controlMode === "user" && qualifies(score) && !scoreSubmitted) {
          return;
        }
        gameOver = false;
        showStartMenu();
        return;
      }
      if (keyCode === ESCAPE) {
        if (!paused) {
          pauseGame();
        } else {
          resumeGame();
        }
        return;
      }
      if (paused) return;
      if (controlMode === "user") {
        if (keyCode === UP_ARROW && direction.dy !== 1) {
          direction = { dx: 0, dy: -1 };
        } else if (keyCode === DOWN_ARROW && direction.dy !== -1) {
          direction = { dx: 0, dy: 1 };
        } else if (keyCode === LEFT_ARROW && direction.dx !== 1) {
          direction = { dx: -1, dy: 0 };
        } else if (keyCode === RIGHT_ARROW && direction.dx !== -1) {
          direction = { dx: 1, dy: 0 };
        }
      }
    }

    function pauseGame() {
      paused = true;
      createPauseMenu();
    }

    function resumeGame() {
      paused = false;
      removePauseMenu();
    }

    function createPauseMenu() {
      pauseMenuDiv = createDiv('');
      pauseMenuDiv.id('pause-menu');
      pauseMenuDiv.parent(document.body);

      let resumeBtn = createMenuButton('Продовжити', resumeGame);
      resumeBtn.parent(pauseMenuDiv);

      let exitBtn = createMenuButton('Головне меню', () => {
        paused = false;
        gameStarted = false;
        removePauseMenu();
        resetGame();
        showStartMenu();
      });
      exitBtn.parent(pauseMenuDiv);
    }

    function removePauseMenu() {
      if (pauseMenuDiv) {
        pauseMenuDiv.remove();
        pauseMenuDiv = null;
      }
    }

    function spawnBonus() {
      let valid = false;
      let x, y;
      let attempts = 0;
      const maxAttempts = 100;
      while (!valid && attempts < maxAttempts) {
        x = floor(random(cols));
        y = floor(random(rows));
        if (isCellFree(x, y)) valid = true;
        attempts++;
      }
      if (!valid) {
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            if (isCellFree(i, j)) {
              x = i;
              y = j;
              valid = true;
              break;
            }
          }
          if (valid) break;
        }
      }
      bonus = { x, y };
    }

    function isCellFree(x, y) {
      for (let part of snake) {
        if (part.x === x && part.y === y) return false;
      }
      return true;
    }

    function collision(newHead) {
      let willGrow = (newHead.x === bonus.x && newHead.y === bonus.y);
      let bodyToCheck = snake.slice();
      if (!willGrow) {
        bodyToCheck.shift();
      }
      for (let segment of bodyToCheck) {
        if (segment.x === newHead.x && segment.y === newHead.y) return true;
      }
      return false;
    }

    function chooseDirection() {
      let head = snake[snake.length - 1];
      let moves = [
        { dx: 1, dy: 0 },
        { dx: -1, dy: 0 },
        { dx: 0, dy: 1 },
        { dx: 0, dy: -1 }
      ];
      moves.sort((a, b) => {
        let newAX = (head.x + a.dx + cols) % cols;
        let newAY = (head.y + a.dy + rows) % rows;
        let newBX = (head.x + b.dx + cols) % cols;
        let newBY = (head.y + b.dy + rows) % rows;
        let dA = Math.abs(newAX - bonus.x) + Math.abs(newAY - bonus.y);
        let dB = Math.abs(newBX - bonus.x) + Math.abs(newBY - bonus.y);
        return dA - dB;
      });
      for (let move of moves) {
        let newX = (head.x + move.dx + cols) % cols;
        let newY = (head.y + move.dy + rows) % rows;
        let candidate = { x: newX, y: newY };
        if (!collision(candidate)) return move;
      }
      return direction;
    }

    function updateScore() {
      scoreDiv.html("Рахунок: " + score);
    }

    function drawGrid() {
      stroke(40);
      strokeWeight(1);
      for (let i = 0; i <= cols; i++) {
        line(borderThickness + i * gridSize, borderThickness,
             borderThickness + i * gridSize, borderThickness + rows * gridSize);
      }
      for (let j = 0; j <= rows; j++) {
        line(borderThickness, borderThickness + j * gridSize,
             borderThickness + cols * gridSize, borderThickness + j * gridSize);
      }
    }

    function drawSnakePixelArt(x, y, s) {
      let snakeArt = [
        [0, 1, 1, 1, 1, 1, 1, 0],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 3, 1, 1, 3, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [0, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 2, 2, 2, 2, 0, 0]
      ];
      for (let i = 0; i < snakeArt.length; i++) {
        for (let j = 0; j < snakeArt[i].length; j++) {
          let cell = snakeArt[i][j];
          if (cell === 0) continue;
          if (cell === 1) fill("#86BB39");
          else if (cell === 2) fill("#D70000");
          else if (cell === 3) fill("#FFFFFF");
          noStroke();
          rect(x + j * s, y + i * s, s, s);
        }
      }
    }
  </script>
</body>
</html>
