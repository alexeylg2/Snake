<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ЗМІЙКОКРАТ</title>
  <!-- Підключаємо p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
  <!-- Підключаємо шрифт "Press Start 2P" -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body { 
      margin: 0; 
      padding: 0; 
      background: #000; 
      color: #fff; 
      font-family: 'Press Start 2P', sans-serif;
      position: relative;
    }
    /* Контейнер для ігрової канви */
    #game-container {
      display: flex;
      justify-content: center;
      margin-top: 20px;
    }
    /* Меню вибору режиму під ігровим полем */
    #menu {
      text-align: center;
      margin-top: 20px;
    }
    .menu-button {
      font-size: 18px;
      padding: 10px 20px;
      margin: 5px;
      background-color: #86BB39;
      border: none;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .menu-button:hover {
      background-color: #75A730;
    }
    /* Красивий лічильник бонусів, розташований по центру під ігровим полем */
    .score-container {
      position: absolute;
      top: calc(20px + 440px + 20px); /* 20px (відступ контейнера) + 440px (висота канви) + 20px (зазор) */
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      padding: 5px 10px;
      border-radius: 8px;
      font-size: 20px;
      font-family: 'Press Start 2P', sans-serif;
    }
    /* Оверлей меню паузи */
    #pause-menu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      z-index: 10;
    }
  </style>
</head>
<body>
  <!-- Контейнер для канви гри -->
  <div id="game-container"></div>
  <!-- Меню вибору режиму (початковий екран) -->
  <div id="menu"></div>

  <script>
    // Розмір клітинки та розміри ігрового поля
    const gridSize = 20;
    const cols = 20;
    const rows = 20;
    const borderThickness = 20; // відступ навколо ігрової зони
    const canvasWidth = cols * gridSize + 2 * borderThickness;
    const canvasHeight = rows * gridSize + 2 * borderThickness;

    let snake = [];
    let direction = { dx: 1, dy: 0 };
    let bonus = {};
    let score = 0;
    
    // Режим керування: "user" або "ai"
    let controlMode = "";
    let gameStarted = false;
    let paused = false;
    let gameOver = false;  // нова змінна для стану "Game over"
    let canvas;
    
    // Елементи меню та лічильника
    let aiButton, userButton;
    let scoreDiv;
    let pauseMenuDiv;
    
    // Змінні для обробки свайпів
    let touchStartX = 0;
    let touchStartY = 0;

    function setup() {
      canvas = createCanvas(canvasWidth, canvasHeight);
      canvas.parent('game-container');
      frameRate(10);
      
      // Створення лічильника бонусів
      scoreDiv = createDiv("Рахунок: 0");
      scoreDiv.class("score-container");
      scoreDiv.parent(document.body);
      
      // Створення кнопок вибору режиму на початковому екрані
      showStartMenu();
      
      resetGame();
    }
    
    function showStartMenu() {
      // При показі меню ховаємо лічильник бонусів
      scoreDiv.hide();
      let menuDiv = select('#menu');
      menuDiv.html(""); // очищення меню
      
      aiButton = createButton('Керування ШІ');
      aiButton.class("menu-button");
      aiButton.parent(menuDiv);
      aiButton.mousePressed(() => {
        controlMode = "ai";
        gameStarted = true;
        gameOver = false;
        menuDiv.html("");
        resetGame();
      });
      
      userButton = createButton('Користувацький режим');
      userButton.class("menu-button");
      userButton.parent(menuDiv);
      userButton.mousePressed(() => {
        controlMode = "user";
        gameStarted = true;
        gameOver = false;
        menuDiv.html("");
        resetGame();
      });
    }
    
    // Скидання гри (новий старт)
    function resetGame() {
      snake = [];
      snake.push({ x: floor(cols / 2), y: floor(rows / 2) });
      direction = { dx: 1, dy: 0 };
      score = 0;
      paused = false;
      gameOver = false;
      spawnBonus();
      updateScore();
      // Показуємо лічильник бонусів лише якщо гра запущена
      if (gameStarted) {
        scoreDiv.show();
      } else {
        scoreDiv.hide();
      }
    }
    
    // Створення бонусу у випадковій вільній клітинці
    function spawnBonus() {
      let valid = false;
      let x, y;
      while (!valid) {
        x = floor(random(cols));
        y = floor(random(rows));
        if (isCellFree(x, y)) {
          valid = true;
        }
      }
      bonus = { x, y };
    }
    
    // Перевірка, що клітинка (x, y) не зайнята змійкою
    function isCellFree(x, y) {
      for (let part of snake) {
        if (part.x === x && part.y === y) return false;
      }
      return true;
    }
    
    // Перевірка зіткнення змійки з собою
    function collision(newHead) {
      let willGrow = (newHead.x === bonus.x && newHead.y === bonus.y);
      let bodyToCheck = snake.slice();
      if (!willGrow) {
        bodyToCheck.shift(); // звільнення хвоста
      }
      for (let segment of bodyToCheck) {
        if (segment.x === newHead.x && segment.y === newHead.y) return true;
      }
      return false;
    }
    
    // Обробка натискань клавіш
    function keyPressed() {
      // Якщо гра закінчена, при натисканні на будь-яку клавішу повертаємося до головного меню
      if (gameOver) {
        gameStarted = false;
        gameOver = false;
        showStartMenu();
        return false;
      }
      
      // При натисканні Esc – перемикаємо режим паузи/продовження
      if (keyCode === ESCAPE) {
        if (!paused) {
          pauseGame();
        } else {
          resumeGame();
        }
        return;
      }
      
      if (paused) return;
      
      if (controlMode === "user") {
        if (keyCode === UP_ARROW && direction.dy !== 1) {
          direction = { dx: 0, dy: -1 };
        } else if (keyCode === DOWN_ARROW && direction.dy !== -1) {
          direction = { dx: 0, dy: 1 };
        } else if (keyCode === LEFT_ARROW && direction.dx !== 1) {
          direction = { dx: -1, dy: 0 };
        } else if (keyCode === RIGHT_ARROW && direction.dx !== -1) {
          direction = { dx: 1, dy: 0 };
        }
      }
    }
    
    // Обробка початку дотику (свайп)
    function touchStarted() {
      if (touches.length > 0) {
        touchStartX = touches[0].x;
        touchStartY = touches[0].y;
      }
      return false;
    }
    
    // Обробка завершення дотику (свайп)
    function touchEnded() {
      if (controlMode !== "user") return false;
      let dx = mouseX - touchStartX;
      let dy = mouseY - touchStartY;
      
      if (abs(dx) < 20 && abs(dy) < 20) return false; // мінімальна відстань свайпа
      
      if (abs(dx) > abs(dy)) {
        if (dx > 0 && direction.dx !== -1) {
          direction = { dx: 1, dy: 0 };
        } else if (dx < 0 && direction.dx !== 1) {
          direction = { dx: -1, dy: 0 };
        }
      } else {
        if (dy > 0 && direction.dy !== -1) {
          direction = { dx: 0, dy: 1 };
        } else if (dy < 0 && direction.dy !== 1) {
          direction = { dx: 0, dy: -1 };
        }
      }
      return false;
    }
    
    // Функції для паузного меню
    function pauseGame() {
      paused = true;
      createPauseMenu();
    }
    
    function resumeGame() {
      paused = false;
      removePauseMenu();
    }
    
    function createPauseMenu() {
      pauseMenuDiv = createDiv('');
      pauseMenuDiv.id('pause-menu');
      pauseMenuDiv.parent(document.body);
      
      let resumeBtn = createButton('Продовжити');
      resumeBtn.class("menu-button");
      resumeBtn.parent(pauseMenuDiv);
      resumeBtn.mousePressed(() => {
        resumeGame();
      });
      
      let exitBtn = createButton('Вихід у головне меню');
      exitBtn.class("menu-button");
      exitBtn.parent(pauseMenuDiv);
      exitBtn.mousePressed(() => {
        paused = false;
        gameStarted = false;
        removePauseMenu();
        resetGame();
        showStartMenu();
      });
    }
    
    function removePauseMenu() {
      if (pauseMenuDiv) {
        pauseMenuDiv.remove();
        pauseMenuDiv = null;
      }
    }
    
    // Функція ІІ для вибору напрямку (на основі мінімальної "манхеттенської" відстані)
    function chooseDirection() {
      let head = snake[snake.length - 1];
      let moves = [
        { dx: 1, dy: 0 },
        { dx: -1, dy: 0 },
        { dx: 0, dy: 1 },
        { dx: 0, dy: -1 }
      ];
      moves.sort((a, b) => {
        let newAX = (head.x + a.dx + cols) % cols;
        let newAY = (head.y + a.dy + rows) % rows;
        let newBX = (head.x + b.dx + cols) % cols;
        let newBY = (head.y + b.dy + rows) % rows;
        let dA = abs(newAX - bonus.x) + abs(newAY - bonus.y);
        let dB = abs(newBX - bonus.x) + abs(newBY - bonus.y);
        return dA - dB;
      });
      
      for (let move of moves) {
        let newX = (head.x + move.dx + cols) % cols;
        let newY = (head.y + move.dy + rows) % rows;
        let candidate = { x: newX, y: newY };
        if (!collision(candidate)) return move;
      }
      return direction;
    }
    
    // Оновлення лічильника бонусів
    function updateScore() {
      scoreDiv.html("Рахунок: " + score);
    }
    
    // Малювання сітки ігрового поля з урахуванням відступу
    function drawGrid() {
      stroke(40);
      strokeWeight(1);
      for (let i = 0; i <= cols; i++) {
        line(borderThickness + i * gridSize, borderThickness, borderThickness + i * gridSize, borderThickness + rows * gridSize);
      }
      for (let j = 0; j <= rows; j++) {
        line(borderThickness, borderThickness + j * gridSize, borderThickness + cols * gridSize, borderThickness + j * gridSize);
      }
    }
    
    // Функція для малювання піксельного зображення змії (8x8 пікселів)
    function drawSnakePixelArt(x, y, s) {
      // Матриця 8x8: 0 – пропуск, 1 – колір (основний, #86BB39), 2 – язик (#D70000), 3 – очі (#FFFFFF)
      let snakeArt = [
        [0, 1, 1, 1, 1, 1, 1, 0],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 3, 1, 1, 3, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [0, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 2, 2, 2, 2, 0, 0]
      ];
      for (let i = 0; i < snakeArt.length; i++) {
        for (let j = 0; j < snakeArt[i].length; j++) {
          let cell = snakeArt[i][j];
          if (cell === 0) continue;
          if (cell === 1) {
            fill("#86BB39");
          } else if (cell === 2) {
            fill("#D70000");
          } else if (cell === 3) {
            fill("#FFFFFF");
          }
          noStroke();
          rect(x + j * s, y + i * s, s, s);
        }
      }
    }
    
    function draw() {
      // Якщо гра не запущена – відображаємо заставку на темному фоні
      if (!gameStarted) {
        background("#1c1c1c");
        // Малюємо піксельну змію (розмір пікселя = 10)
        let s = 10;
        let artW = 8 * s;
        let artH = 8 * s;
        // Зміщуємо змію вгору, щоб між нею та заголовком був відступ
        drawSnakePixelArt(width / 2 - artW / 2, height / 2 - artH - 40, s);
        fill("#86BB39");
        textAlign(CENTER, CENTER);
        textSize(48);
        text("Змійкократ", width / 2, height / 2 + 10);
        textSize(24);
        text("Виберіть режим керування", width / 2, height / 2 + 50);
        return;
      }
      
      // Малюємо ігрове поле
      background("#f0f0f0");
      fill("#343434");
      noStroke();
      rect(borderThickness, borderThickness, cols * gridSize, rows * gridSize);
      drawGrid();
      
      if (paused) {
        return;
      }
      
      // Якщо гра завершена, відображаємо "GAME OVER" та інструкцію
      if (gameOver) {
        // Малюємо бонус та змійку (остання зафіксована конфігурація)
        fill("#EC612A");
        rect(borderThickness + bonus.x * gridSize, borderThickness + bonus.y * gridSize, gridSize, gridSize);
        fill("#86BB39");
        for (let part of snake) {
          rect(borderThickness + part.x * gridSize, borderThickness + part.y * gridSize, gridSize, gridSize);
        }
        fill("#D70000");
        textAlign(CENTER, CENTER);
        textSize(48);
        text("GAME OVER", width / 2, height / 2);
        textSize(24);
        text("Press any key", width / 2, height / 2 + 40);
        return;
      }
      
      // Оновлюємо гру, якщо не "Game over"
      if (controlMode === "ai") {
        direction = chooseDirection();
      }
      
      let head = snake[snake.length - 1];
      let newX = (head.x + direction.dx + cols) % cols;
      let newY = (head.y + direction.dy + rows) % rows;
      let newHead = { x: newX, y: newY };
      
      if (collision(newHead)) {
        gameOver = true;
      } else {
        snake.push(newHead);
        
        if (newHead.x === bonus.x && newHead.y === bonus.y) {
          score++;
          updateScore();
          spawnBonus();
        } else {
          snake.shift();
        }
      }
      
      // Малюємо бонус та змійку
      fill("#EC612A");
      rect(borderThickness + bonus.x * gridSize, borderThickness + bonus.y * gridSize, gridSize, gridSize);
      fill("#86BB39");
      for (let part of snake) {
        rect(borderThickness + part.x * gridSize, borderThickness + part.y * gridSize, gridSize, gridSize);
      }
    }
  </script>
</body>
</html>
